Data Cell
{
	Cell = string * double.c_cell ++ Cell * Cell * double.c_tree;
}

Data Table['t]
{
	Table = c_nil ++ 't * Table['t].c_table;
}

// (letter * code)
Data Code
{
	Code = string * string.c_code;
}

Scheme Haffman
{
	file = "poem.txt".readFile;
	@ = file.(id * ((c_nil * "" * id.table(split, addInTable)
			 .sort(putInSorted(cellValue))
			 .buildTree(putInSorted(cellValue), createTree(cellValue)))
			 .getLetterTableFromTree))
			 .encode(split, getCode, log)
		 .log;

	// string * encodingTable -> encoded string
	Fun encode[split, getCode, log]
	{
		str = [1];
		table = [2];
		splitted_str = str.split;
		first_char = splitted_str.[1];
		remaining_string = str.split.[2];
		@ = (str.length * 1).equal -> (str * table).getCode,
						(((first_char * table).getCode * " ").cat * (remaining_string * table).encode).cat;
	}

	Fun getCode
	{
		char = [1];
		table = [2];
		table_separate = table.~c_table;
		table_head = table_separate.[1];
		table_tail = table_separate.[2];
		table_head_code = table_head.~c_code;
		@ = (table_head_code.[1] * char).equal -> table_head_code.[2], (char * table_tail).getCode;
	}

	// tree -> table with codes
	Fun getLetterTableFromTree
	{
		table = [1];
		currentCode = [2];
		tree = [3];
		is_cell = tree.~c_cell;
		cell_char = is_cell.[1];
		tree_branches = tree.~c_tree;
		tree_left = tree_branches.[1];
		tree_right = tree_branches.[2];
		@ = is_cell -> ((cell_char * currentCode).c_code * table).c_table,
						(
							(table * (currentCode * "1").cat * tree_right).getLetterTableFromTree
							* (currentCode * "0").cat
							* tree_left)
								.getLetterTableFromTree;
  }

	// string -> unsorted Table
	Fun table[split, addInTable]
	{
		str = [1];
		@ = (str.length * 0).equal -> c_nil,
																	str.split.([1] * [2].table).addInTable;
	}

	// Table -> sorted Table
	Fun sort[putInSorted]
	{
		table = [1];
		table_empty = table.~c_nil;
		table_separate = table.~c_table;
		table_head = table_separate.[1];
		table_tail = table_separate.[2];
		table_head_pair = table_head.~c_cell;

		@ = table_empty -> c_nil,
							(table_head * table_tail.sort).putInSorted;
	}

	// (Cell, sorted Table) - > sorted Table
	Fun putInSorted[cellValue]
	{
		cell = [1];
		cell_value = cell.cellValue;
		table = [2];
		table_empty = table.~c_nil;
		table_separate = table.~c_table;
		table_head = table_separate.[1];
		table_tail = table_separate.[2];
		table_head_value = table_head.cellValue;
		@ = table_empty -> (cell * table).c_table,
						(cell_value * table_head_value).greater ->
								(table_head * (cell * table_tail).putInSorted).c_table,
										(cell * table).c_table;
	}

	// (sorted Table) -> Cell tree
	Fun buildTree[putInSorted, createTree]
	{
		table = [1];
		table_empty = table.~c_nil;
		table_separate = table.~c_table;
		table_head = table_separate.[1];
		table_tail = table_separate.[2];
		table_tail_separate = table_tail.~c_table;
		table_tail_head = table_tail_separate.[1];
		table_tail_tail = table_tail_separate.[2];
		table_head_pair = table_head.~c_cell;

		@ =	table_tail.~c_nil -> table_head,
								((table_head * table_tail_head).createTree * table_tail_tail).putInSorted.buildTree;
	}

	Fun createTree[cellValue]
	{
		leftCell = [1];
		rightCell = [2];
		@ = (leftCell * rightCell * (leftCell.cellValue * rightCell.cellValue).add).c_tree;
	}

	Fun cellValue
	{
		cell = [1];
		@ = cell.~c_cell -> cell.~c_cell.[2], cell.~c_tree.[3];
	}

	// (string * Table) -> Table
	Fun addInTable
	{
		char = [1];
		table = [2];
		table_empty = table.~c_nil;
		table_separate = table.~c_table;
		table_head = table_separate.[1];
		table_tail = table_separate.[2];
		table_head_pair = table_head.~c_cell;
		table_head_matches = (table_head_pair.[1] * char).equal;
		table_head_increase = ((table_head_pair.[1] * (table_head_pair.[2] * 1).add).c_cell*table_tail).c_table;
		new_table = ((char * 1.0).c_cell * c_nil).c_table;
		@ = table_empty -> new_table,
						table_head_matches -> table_head_increase,
										(table_head * (char * table_tail).addInTable).c_table;
	}

	Fun split
	{
		@ = ([1]*"([^])([^]*)" ).match;
	}

	Fun log
	{
		@ = print."\n".print;
	}
}
Application
%Haffman()
