\section{Цель работы}
	Изучение основ работы с генетическими алгоритмами.
\section{Порядок выполенения работы}
	\subsection{Задача}
		Задача основана на другой задаче, описанной на сайте \href{http://www.codeabbey.com/index/task_view/random-search-optimization}{www.codeabbey.com}.

		Дана некоторая беспилотная транспортная машина бесконечно малого размера такая, что может находится в одной точке с некоторым контейнером. Контейнер и машина связаны эластической пружиной так, что когда машина удаляется на достаточное расстояние от контейнера, сила натяжения начинает притягивать коробку к машине.
		
		Когда машина достигает 100м отметки, она останавливается, но коробка может перемещаться дальше.
		
		Каждые 20м есть возможность изменить скорость машины не более, чем на 3м/c, из-за опасности возгорания двигателя. Таким образом 100-метровый путь разделён на 5 частей и на каждой из частей машина движется с постоянной скоростью. На границе скорость машины резко изменяется.
		
		Алгоритм симуляции движения известен. Необходимо найти 5 значений скорости, для которых время от момента начала движения до момента остановки контейнера в точке 100м будет минимально.
		
		
	\subsection{Инструменты разработки}
		Для решения задачи выбран язык Java и библиотека \href{http://jenetics.io/}{Jenetics}.  На данный момент Jenetics явяется самой актуальной, т.к. использует все последние возможности языка Java, что сильно упрощает процесс создания алгоритма.L Руководство по использованию библиотеки доступно по \href{http://jenetics.io/manual/manual-3.6.0.pdf}{ссылке}.
		
	\subsection{Генотип}
		Т.к. параметры функции - 5 вещественных чисел с разными множествами допустимых значений, использован генотип, состоящий из 5-и хромосом, содержащих по 1 вещественному гену.
		
		\begin{ListingEnv}[H]% буква H означает Here, ставим здесь,
			% элементы, которые нежелательно разрывать обычно не ставят
			% посреди страницы: вместо H используется t (top, сверху страницы),
			% или b (bottom) или p (page, на отдельной странице)
			%    \captionsetup{format=tablenocaption}% должен стоять до самого caption
			%    \thisfloatsetup{\capposition=top}%
			\caption{Описание генотипа}
			% далее метка для ссылки:
			\label{list:hwbeauty}
			% окружение учитывает пробелы и табляции и приеняет их в сответсвии с настройкми
			\begin{lstlisting}[language={Java}]
			final Factory<Genotype<DoubleGene>> genotypeScalarFactory = Genotype.of(DoubleChromosome.of(0, 3, 1)
				, DoubleChromosome.of(0, 6, 1)
				, DoubleChromosome.of(0, 9, 1)
				, DoubleChromosome.of(0, 6, 1)
				, DoubleChromosome.of(0, 3, 1)
			);
			\end{lstlisting}
		\end{ListingEnv}%
	
	\subsection{Целевая функция}
		Целевая функция определена в задании и вычисляет время. 
		\begin{ListingEnv}[H]
		\caption{Описание целевой функции}
		% далее метка для ссылки:
		% окружение учитывает пробелы и табляции и приеняет их в сответсвии с настройкми
			\begin{lstlisting}[language={Java}]
			static double run(double[] speedArray) {
				Box box = new Box();
				Mover mover = new Mover(speedArray);
				
				double time = 0;     // initial time
				double dt = 0.2; // time step of simulation
				double springElasticity = 0.5;  // coefficient of elasticity of the spring (as in Hooke's Law)
				
				while (mover.getCoordinate() <= 100
				|| Math.abs(mover.getCoordinate() - box.getCoordinate()) > 0.1
				|| Math.abs(box.getSpeed()) > 0.1) {
					double force_spring = springElasticity * (mover.getCoordinate() - box.getCoordinate());
					double force_friction = box.getFriction() * box.getSpeed();
					double force_total = force_spring + force_friction;
					double acceleration = force_total / box.getMass();
					
					box.move(box.getSpeed() * dt);
					box.accelerate(acceleration * dt);
					time += dt;
					mover.move(mover.getSpeed() * dt);
				}
				return time;
				
			}
			\end{lstlisting}
		\end{ListingEnv}%
		
		Задача алгоритма -- минимизировать данную функцию.
	
	
	\subsection{Подбор параметров симуляции}
		\subsubsection{Размер популяции}
			Т.к. в данном фреймворке невозможно фиксировать начальную выборку, симуляция проводилась 10 раз, после чего определялось среднее. Критерий останова - количество поколений равно 100 000.
			
			\begin{table}[h]
				\centering
				\caption{Влияние размера популяции}
				\label{my-label}
				\begin{tabular}{|c|c|c|}
					\hline
					Размер популяции & ср. время генерации, сек & ср. мин. зн-е целевой ф-ии \\ \hline
					10 & 10.31 & 25.36 \\ \hline
					100 & 58.74 & 24.88 \\ \hline
					140 & 74.63 & 24.8 \\ \hline
				\end{tabular}
			\end{table}
		
			Размер популяции 100 достаточно хорошо приближает к минимуму в 24.8 сек.
			\FloatBarrier
		\subsubsection{Селектор}
			Библиотека Jenetics содержит ряд селекторов:
			\begin{itemize}
				\item Tournament Selector (Состязание) -- Происходит состязание случайной выборки из $ n $ индивидов популяции. Индивид побеждает только если значение целевой функции на нём лучше других $n-1$ соперников. Худший индивид никогда не выживает. 

				\item Truncation Selector (Сокращение) -- Индивиды сортируются по значению целевой функции. Выбираются n лучших.
				\item Monte Carlo Selector -- Случайно выбирает индивидов из популяции.
				\item Linear Rank Selector (Линейное ранжирование) -- Индивиды сортируются по значению целевой функции. Ранг N присвоен лучшему индивиду, а ранг 1 худшему. Вероятность выбора индивида $ i $ линейно ассоциируются с индивидами соответственно их рангу по формуле:
				
				\[P(i) = \dfrac{1}{N}(n^-+(n^+-n^-)\dfrac{i-1}{N-1}),\]
				где $ \frac{n^-}{N} $ - вероятность худшего индивида быть выбранным, а $ \frac{n^+}{N} $ - вероятность лучшего индивида быть выбранным.
				\item Exponential Rank Selector (Экспоненциальное ранжирование) -- Аналогично с линейным, ассоциирует с индивидом вероятность, используя экспоненциальную функцию:
				\[P(i)=(c-1)\dfrac{c^{i-1}}{c^N-1},\]
				где значение $ с $ должно быть в диапазоне $[0...1)$.
				\item Boltzmann Selector (Больцмана) -- Вероятность выбора селектором Больцмана определена как
				\[P(i)=\dfrac{e^{b-f}}{Z},\]
				где $ b $ - параметр, контролирующий интенсивность селекции, а $ Z $ определена как
				\[Z=\sum_{i=1}^{n}e^{f_x},\] 
				\item Stochastic Universal Selector (Стохастический универсальный) – строится линия, в которой каждому родителю ставится в соответствие её часть определенного размера (в зависимости от вероятности родителя), затем алгоритм пробегает по линии шагами одинаковой длины и выбирает родителей в зависимости от того, на какую часть линии попал шаг.
			\end{itemize}
		
		
			Определим наилучший селектор для решения данной задачи. Здесь и далее критерий останова -- достижение порога в 24.8 сек. За величину популяции примем значение 100.
			
			\begin{table}[h]
				\centering
				\caption{Влияние выбранного селектора}
				\label{my-label}
				\begin{tabular}{|c|c|c|c|}
					\hline
					\multicolumn{2}{|c|}{Селектор} & ср. время, сек. & ср. Количество поколений \\ \hline
					\multirow{10}{*}{Состязание} & 5 & 77,74 & 57620 \\ \cline{2-4} 
					& 10 & 94,22 & 85784 \\ \cline{2-4} 
					& 15 & 87,82 & 78951 \\ \cline{2-4} 
					& 20 & 70,06 & 60142 \\ \cline{2-4} 
					& 25 & 90,01 & 72168 \\ \cline{2-4} 
					& 30 & 116,48 & 86680 \\ \cline{2-4} 
					& 35 & 93,96 & 74218 \\ \cline{2-4} 
					& 40 & 148,77 & 113463 \\ \cline{2-4} 
					& 45 & 160,62 & 111904 \\ \cline{2-4} 
					& 50 & 175,42 & 109056 \\ \hline
					\multicolumn{2}{|c|}{\begin{tabular}[c]{@{}c@{}}Стохастический\\ универсальный\end{tabular}} & \multicolumn{2}{c|}{не достиг решения за приемлемое время} \\ \hline
					\multicolumn{2}{|c|}{Монте-Карло} & \multicolumn{2}{c|}{не достиг решения за приемлемое время} \\ \hline
					\multicolumn{2}{|c|}{Сокращение} & 118,65 & 97090 \\ \hline
					\multicolumn{2}{|c|}{Линейное ранжирование} &
					\multicolumn{2}{c|}{не достиг решения за приемлемое время} \\ \hline
					\multirow{8}{*}{\begin{tabular}[c]{@{}c@{}}Экспоненциальное\\ ранжирование\end{tabular}} & 0 & 91,77 & 65537 \\ \cline{2-4} 
					& 0,2 & 91,14 & 76180 \\ \cline{2-4} 
					& 0,4 & 87,39 & 79575 \\ \cline{2-4} 
					& 0,6 & 131,93 & 64854 \\ \cline{2-4} 
					& 0,8 & 64,82 & 50218 \\ \cline{2-4} 
					& 0.85 & 38,19 & 34691 \\ \cline{2-4} 
					& 0.9 & 70,41 & 67125 \\ \cline{2-4} 
					& 0.95 & 59,43 & 57725 \\ \hline
					\multirow{3}{*}{Больцмана} & 2 & 148,49 & 103226 \\ \cline{2-4} 
					& 3 & 100,56 & 72088 \\ \cline{2-4} 
					& 4 & 212,94 & 148157 \\ \hline
				\end{tabular}
			\end{table}
			\FloatBarrier
		
			Оптимальным является селектор экспоненциального ранжирования в параметром 0,85.
		
		\subsubsection{Мутаторы/Рекомбинаторы}
			Для выбраной структуры генотипа имеет смысл использовать мутаторы и рекомбинаторы типов MeanAlterer, GaussianMutator и Mutator.
			
			\begin{itemize}
				\item Mean Alterer - вероятностный рекомбинатор.
				\item Gaussian Mutator (мутатор Гаусса) -- выбирает новое значение соответственно распределению Гаусса. Дисперсия нового значения будет равна
				\[\hat{\sigma }^2 = \left ( \frac{ g_{max} - g_{min} }{4}\right )^2.\]
				\item Mutator (Мутатор) --  Вероятность мутации $ P(m) $ -- вероятность того, что определённый ген из всей популяции мутирует. Количество доступных для мутации генов :
				
				\[N_P N_{g}=N_P \sum_{i=0}^{N_{G}-1}N_{C[i]}\]
				где $ N_P $ -- размер популяции, $ N_G $ --  количество генов в генотипе. Среднее количество генов, мутировавших данным мутатором:
				\[\hat{\mu}=N_{P}N_{g}\cdot P(m).\]
			\end{itemize}
			
			\begin{table}[h]
				\centering
				\caption{Влияние различных мутаторов и рекомбинаторов}
				\label{my-label}
				\begin{tabular}{|c|c|c|c|}
					\hline
					\multicolumn{2}{|c|}{Мутатор/Рекомбинатор} & ср. время, сек. & ср. Количество поколений \\ \hline
					\multirow{10}{*}{\begin{tabular}[c]{@{}c@{}}Простейший \\ Мутатор\end{tabular}} & 0,05 & 68,30 & 109295 \\ \cline{2-4} 
					& 0,1 & 67,58 & 85445 \\ \cline{2-4} 
					& 0,15 & 52,22 & 51368 \\ \cline{2-4} 
					& 0,2 & 55,20 & 50798 \\ \cline{2-4} 
					& 0,25 & 66,97 & 34450 \\ \cline{2-4} 
					& 0,3 & 71,61 & 48011 \\ \cline{2-4} 
					& 0,35 & 56,55 & 37317 \\ \cline{2-4} 
					& 0,4 & 72,57 & 38250 \\ \cline{2-4} 
					& 0,45 & 98,84 & 55808 \\ \cline{2-4} 
					& 0,5 & 419,52 & 157323 \\ \hline
					\multirow{19}{*}{\begin{tabular}[c]{@{}c@{}}Мутатор\\ Гаусса\end{tabular}} & 0,05 & 20,86 & 50091 \\ \cline{2-4} 
					& 0,1 & 5,21 & 9973 \\ \cline{2-4} 
					& 0,15 & 2,27 & 3537 \\ \cline{2-4} 
					& 0,2 & 4,21 & 1727 \\ \cline{2-4} 
					& 0,25 & 1,70 & 1820 \\ \cline{2-4} 
					& 0.3 & 1,08 & 1198 \\ \cline{2-4} 
					& 0.35 & 1,19 & 1112 \\ \cline{2-4} 
					& 0.4 & 0,82 & 686 \\ \cline{2-4} 
					& 0,45 & 1,17 & 755 \\ \cline{2-4} 
					& 0,5 & 0,76 & 578 \\ \cline{2-4} 
					& 0,55 & 0,92 & 736 \\ \cline{2-4} 
					& 0,6 & 1,56 & 624 \\ \cline{2-4} 
					& 0,65 & 0,46 & 348 \\ \cline{2-4} 
					& 0,7 & 0,89 & 619 \\ \cline{2-4} 
					& 0,75 & 0,51 & 353 \\ \cline{2-4} 
					& 0,8 & 0,93 & 458 \\ \cline{2-4} 
					& 0,85 & 0,62 & 375 \\ \cline{2-4} 
					& 0,9 & 0,60 & 430 \\ \cline{2-4} 
					& 0,95 & 1,21 & 549 \\ \hline
					\multicolumn{2}{|c|}{\begin{tabular}[c]{@{}c@{}}Рекомбинатор\\ среднего значения\end{tabular}} & \multicolumn{2}{c|}{не достиг решения за приемлемое время} \\ \hline
				\end{tabular}
			\end{table}
			\FloatBarrier
			Из таблицы видно, что для данной задачи оптимально выбрать мутатор Гаусса со значением вероятности, лежащем на отрезке $[0.75 , 0.85] $
			
			
		\subsection{Листинг}
			Листинг программы доступен на \href{https://github.com/goto1134/TransportJenetics}{GitHub}.
	